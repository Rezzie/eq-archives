<HTML><HEAD><TITLE>Is there a reason Showeq put a file on my EQ machine desguised as a WORD document? - HackersQuest Discussion Board</title><META HTTP-EQUIV="Pragma" CONTENT="no-cache">

</head>
<BODY bgcolor="#000000"   text="#ffffff" link="#00ff00" alink="#00ff00" vlink="#00ff00" marginheight=0 marginwidth=0 topmargin=0 leftmargin=0 rightmargin=0>

<FONT SIZE="2" FACE="Verdana, Arial"><center>
<table border=0 width=95%><TR>
<td valign=top align=left><A HREF="http://www.ethernalquest.com/cgi-bin/Ultimate.cgi?action=intro&BypassCookie=true"><IMG SRC="http://www.ethernalquest.com/ubb/../images/hq-title-shock.gif" BORDER=0></A>

</td>
<td valign=top NOWRAP>
<FONT SIZE="1" FACE="Verdana, Arial">
<IMG SRC="http://www.ethernalquest.com/ubb/open.gif"  BORDER=0>&nbsp;&nbsp;<A HREF="http://www.ethernalquest.com/cgi-bin/Ultimate.cgi?action=intro&BypassCookie=true">HackersQuest Discussion Board</A>
<br><IMG SRC="http://www.ethernalquest.com/ubb/tline.gif" BORDER=0><IMG SRC="http://www.ethernalquest.com/ubb/open.gif"  BORDER=0>&nbsp;&nbsp;<A HREF="http://www.ethernalquest.com/cgi-bin/forumdisplay.cgi?action=topics&forum=ShowEQ&number=3">ShowEQ</A>
<br>
<IMG SRC="http://www.ethernalquest.com/ubb/tline3.gif" BORDER=0><IMG SRC="http://www.ethernalquest.com/ubb/open.gif" BORDER=0>&nbsp;&nbsp;Is there a reason Showeq put a file on my EQ machine desguised as a WORD document? 
<center>
<P><FONT SIZE="2" FACE="Verdana, Arial">
<A HREF="http://www.ethernalquest.com/cgi-bin/postings.cgi?action=newtopic&number=3&forum=ShowEQ"><IMG SRC="http://www.ethernalquest.com/ubb/hq-post.jpg"  BORDER=0 ALT="Post New Topic"></A>&nbsp;&nbsp;<A HREF="http://www.ethernalquest.com/cgi-bin/postings.cgi?action=reply&forum=ShowEQ&number=3&topic=001671.cgi&TopicSubject=Is+there+a+reason+Showeq+put+a+file+on+my+EQ+machine+desguised+as+a+WORD+document|QUS|"><IMG SRC="http://www.ethernalquest.com/ubb/hq-reply.jpg" BORDER=0 ALT="Post A Reply"></A></FONT>
<BR>
<A HREF="http://www.ethernalquest.com/cgi-bin/ubbmisc.cgi?action=editbio&Browser=&DaysPrune=&LastLogin="><ACRONYM TITLE="Click here to edit your profile.">profile</ACRONYM></A> | <A HREF="http://www.ethernalquest.com/cgi-bin/Ultimate.cgi?action=agree"><ACRONYM TITLE="Registration is free!">register</ACRONYM></A> | <A HREF="http://www.ethernalquest.com/cgi-bin/ubbmisc.cgi?action=setprefs"><ACRONYM TITLE="Set your preferences.">preferences</ACRONYM></A> | <A HREF="http://www.ethernalquest.com/ubb/faq.html" target=_blank><ACRONYM TITLE="Frequently Asked Questions">faq</ACRONYM></A> | <A HREF="http://www.ethernalquest.com/cgi-bin/search.cgi?action=intro&default=3"><ACRONYM TITLE="Perform a search by keyword, date, or name.">search</ACRONYM></A>
</font>
</center>
</td></tr>
</table>
<table border=0 width=95%>
<tr><TD valign=bottom align=left><FONT SIZE="1" FACE="Verdana, Arial"><IMG SRC="http://www.ethernalquest.com/ubb/ubbfriendminiicon.gif" BORDER=0> <A HREF="http://www.ethernalquest.com/cgi-bin/ubbmisc.cgi?action=sendthread&thread=http://www.ethernalquest.com/ubb/Forum3/HTML/001671.html&Subject=Is+there+a+reason+Showeq+put+a+file+on+my+EQ+machine+desguised+as+a+WORD+document|QUS|">UBBFriend: Email This Page to Someone!</A>   </font></TD>
<TD align=right  valign=bottom><FONT SIZE="1" FACE="Verdana, Arial">
<A HREF="http://www.ethernalquest.com/cgi-bin/ubbmisc.cgi?action=findthread&forum=Forum3&number=3&thisthread=001671&go=newer"><ACRONYM TITLE="Go to the next newest topic in this forum.">next newest topic</ACRONYM></A> | <A HREF="http://www.ethernalquest.com/cgi-bin/ubbmisc.cgi?action=findthread&forum=Forum3&number=3&thisthread=001671&go=older"><ACRONYM TITLE="Go to the next oldest topic in this forum.">next oldest topic</ACRONYM></A></font>
</TD></tr></table>


<table width=95% border=0 cellspacing=1 cellpadding=4>
<TR bgcolor="#000000">
<TD valign=middle width=18%>
<FONT SIZE="1" face="Verdana, Arial" color="#00ff00"><B>Author</B></FONT>
</TD>
<TD valign=middle>
<FONT SIZE="1" face="Verdana, Arial" color="#00ff00"><B>Topic:&nbsp;&nbsp; Is there a reason Showeq put a file on my EQ machine desguised as a WORD document?</B></FONT>
</TD>
</TR><tr bgcolor="#1f1f1f">
	<TD width=18% valign=top>
	<FONT SIZE="2" face="Verdana, Arial"><B>GnomeRH7</B></font><BR><FONT SIZE="1" face="Verdana, Arial">Decaying Skeleton </FONT>
</td>
<TD>
<IMG SRC="http://www.ethernalquest.com/ubb/icons/icon1.gif" BORDER=0 ALIGN=ABSCENTER>
<FONT SIZE="2" FACE="Verdana, Arial">
<FONT SIZE="1" color="#32cd32" face="Verdana, Arial">posted 05-14-2001 06:00 AM &nbsp;&nbsp;&nbsp;
<A HREF="http://www.ethernalquest.com/cgi-bin/ubbmisc.cgi?action=getbio&UserName=GnomeRH7" target=_blank>
<IMG SRC="http://www.ethernalquest.com/ubb/profile.gif" BORDER=0 ALT="Click Here to See the Profile for GnomeRH7"></A> &nbsp;&nbsp;<A HREF="http://www.ethernalquest.com/cgi-bin/Ultimate.cgi?action=email&ToWhom=GnomeRH7" target=_blank><IMG SRC="http://www.ethernalquest.com/ubb/email.gif" BORDER=0 ALT="Click Here to Email GnomeRH7"></A>&nbsp;&nbsp; &nbsp;&nbsp;<A HREF="http://www.ethernalquest.com/cgi-bin/postings.cgi?action=editpost&forum=ShowEQ&number=3&topic=001671.cgi&ReplyNum=000000&TopicSubject=Is+there+a+reason+Showeq+put+a+file+on+my+EQ+machine+desguised+as+a+WORD+document|QUS|"><IMG SRC="http://www.ethernalquest.com/ubb/edit.gif"  BORDER=0 ALT="Edit/Delete Message"></A> 
</FONT><HR>I found this document in "My Documents" under the title of one of my room-mates nursing homework assignment.  I have no idea why it is on my EQ computer and not on my showeq computer, anyone have any ideas?<P><BR> that can use this item<BR>  char unknown15;		// Placeholder<BR>  char numSlots;		// number of slots?-ATB<BR>  char unknown16;               // more padding.<BR>  UBYTE level;			// Casting level<BR>  char number;			// Number of items in stack<BR>  char unknown8;		// Placeholder<BR>  UWORD spellId;		// spellId of special effect<BR>  char unknown9[26];		// Placeholder<BR>};<P>/* Specific Structures defining opcodes */<P>/* Item owned by the player */<BR>struct itemPlayerStruct<BR>{<BR>  char opCode;			// Was 0x60, now 0x64<BR>  char version;			// 0x21<BR>  struct itemStruct item;	// Refer to itemStruct for members<BR>};<P>/* Item received by the player */<BR>struct itemReceivedPlayerStruct<BR>{<BR>  char opCode;			// Always 0x31<BR>  char version;			// 0x21<BR>  struct itemStruct item;	// Refer to itemStruct for members<BR>};<P>/* Item in a shop */<BR>struct itemShopStruct<BR>{<BR>  char opCode;			// Was 0x14, now 0x0c<BR>  char version;			// 0x21<BR>  char unknown0[4];		// Shopkeeper ID must be in here<BR>  char itemType;		// 0 - item, 1 - container, 2 - book<BR>  struct itemStruct item;	// Refer to itemStruct for members<BR>};<P>/* client changes target struct */<BR>struct clientTargetStruct<BR>{<BR>  char opCode;			// Was 0x62<BR>  char version;			// 0x21<BR>  UWORD newTarget;<BR>  UWORD unknown0;<BR>};<P><BR>/* Channel Message received or sent*/<BR>struct channelMessageStruct<BR>{<BR>  char opCode;			// Always 0x41<BR>  char version;			// 0x21<BR>  //unsigned char unknown0[32];		// Placeholder<BR>  UWORD unknown0[16];<BR>  char sender[23];		// The senders name (len might be wrong)<BR>  //unsigned char unknown1[8];		// Placeholder<BR>  unsigned char unknown1[9];<BR>  unsigned char language;<BR>  char unknown2[1];<BR>  unsigned char chanNum;<BR>  char unknown3[3];<P>  char message[0];		// Variable length message<BR>};<P>/* Delete Spawn */<BR>struct deleteSpawnStruct<BR>{<BR>  char opCode;			// Always 0x37 was 0x37 now 0xD8<BR>  char version;			// 0x21<BR>  UWORD spawnId;			// Spawn ID to delete<BR>};<P>/* Spawn generic struct */<BR>struct spawnStruct<BR>{<BR>  unsigned char unknown0[49];		// Placeholder<BR>  /*char STR;			// Strength<BR>  unsigned char STA;			// Stamina<BR>  unsigned char WIS;			// Wisdom<BR>  unsigned char DEX;			// Dexterity<BR>  unsigned char AGI;			// Agility<BR>  unsigned char CHA;			// Charisma<BR>  unsigned char INT;			// Intelligence<P>  unsigned char unknown01[40];		// Placeholder<BR>*/<P>  char heading;<BR>  char deltaHeading;<BR>  WORD yPos;			// Y Position<BR>  WORD xPos;			// X Position<BR>  WORD zPos;<BR>  DWORD deltaY:10,		// Velocity Y<BR>         spacer1:1,<BR>         deltaZ:10,		//  Velocity Z<BR>         spacer2:1,<BR>         deltaX:10;		//  Velocity X<P>  unsigned char unknown1[1];		// Placeholder<BR>  UWORD spawnId;		// Id of new spawn<BR>  unsigned char unknown2[2];		// Placeholder<BR>  UWORD petOwnerId;              // Id of pet owner (0 if not a pet)<BR>  WORD maxHp;			// Maximum hp's of Spawn<BR>  WORD curHp;			// Current hp's of Spawn<BR>  UBYTE race;			// Race<BR>  UBYTE NPC;			// NPC flag, 0 = player, 1 = NPC, 2 = corpse<BR>  UBYTE class_;			// Class<BR>  UBYTE Gender;		        // Gender Flag, 0 = Male, 1 = Female, 2 = Other<BR>  UBYTE level;			// Level of spawn (might be one byte)<BR>  unsigned char unknown8[4];             // Placeholder<BR>  UBYTE light;                  // Light emitting<BR>  unsigned char unknown4[9];	        // Placeholder<BR>  unsigned char equipment[9];   // Equipment worn<BR>  char name[30];		// Name of spawn (len is 30 or less)<BR>  char lastname[20];	        // Last Name of player<BR>  UWORD unknown3;		// Placeholder<BR>  DWORD unknown5;<BR>};<P>/* New Spawn */<BR>struct newSpawnStruct<BR>{<BR>  char opCode;			// Always 0x46<BR>  char version;			// 0x21<BR>  DWORD unknown1;<BR>  struct spawnStruct spawn;<BR>};<P>/** DB spawn struct (adds zone spawn was in) **/<BR>struct dbSpawnStruct<BR>{<BR>   struct spawnStruct spawn;<BR>   char zoneName[40];<BR>};<P>// Pet spawn struct (pets pet and owner in one struct)<BR>struct petStruct <BR>{<BR>   struct spawnStruct owner;<BR>   struct spawnStruct pet;<BR>};<P>/* Book belonging to player */<BR>struct bookPlayerStruct<BR>{<BR>  char opCode;			// Was 0x61 now 0x65 (untested)<BR>  char version;			// 0x21<BR>  char name[35];		// Name of item<BR>  char lore[60];		// Lore text, same as name if no lore<BR>  char idfile[6];		// Don't know what this is used for, eg: IT63<BR>  WORD flag;			// 0x5f31 normal item, 0x3633 player made<BR>  //char unknown0[37];		// Placeholder replaced by below<BR>/*22*/  char unknown0[22];		// Placeholder<BR>/*23*/  UBYTE weight;			// Weight of item<BR>/*24*/  char nosave;			// Nosave flag 1=normal, 0=nosave, -1=spell?<BR>/*25*/  char nodrop;			// Nodrop flag 1=normal, 0=nodrop, -1=??<BR>/*26*/  UBYTE size;			// Size of item<BR>/*27*/  char unknown5;		// Placeholder<BR>/*29*/  UWORD itemNr;			// Unique item type number<BR>/*31*/  UWORD iconNr;			// Icon nr<BR>/*32*/  char equipSlot;		// Current Equip slot<BR>/*33*/  char unknown13;		// Placeholder<BR>/*37*/  UDWORD slots_;		// Slots where this item goes<BR>  DWORD cost;			// Item cost in copper<BR>  char unknown1[23];		// Placeholder<BR>  char file[15];		// Filename of text on server<BR>  char unknown2[12];		// Placeholder<BR>};<P>/* Container Belonging to Player */<BR>struct containerPlayerStruct<BR>{<BR>  char opCode;			// Was 0x62, now 0x66 (untested)<BR>  char version;			// 0x21<BR>  char name[35];		// Name of container <BR>  char lore[60];		// Lore text, same as name if no lore<BR>//  char unknown0[45];		// Placeholder<BR>//  these replaced unknown0:<BR>/*06*/  char idfile[6];		// Don't know what this is used for, eg: IT63<BR>/*08*/  WORD flag;			// 0x5f31 normal item, 0x3633 player made<BR>/*30*/  char unknown0[22];		// Placeholder<BR>/*31*/  UBYTE weight;			// Weight of item<BR>/*32*/  char nosave;			// Nosave flag 1=normal, 0=nosave, -1=spell?<BR>/*33*/  char nodrop;			// Nodrop flag 1=normal, 0=nodrop, -1=??<BR>/*34*/  UBYTE size;			// Size of item<BR>/*35*/  char unknown5;		// Placeholder<BR>/*37*/  UWORD itemNr;			// Unique item type number<BR>/*39*/  UWORD iconNr;			// Icon nr<BR>/*40*/  char equipSlot;		// Current Equip slot<BR>/*41*/  char unknown13;		// Placeholder<BR>/*45*/  UDWORD slots_;		// Slots where this item goes<P>  DWORD cost;			// Item cost in copper<BR>//  char unknown1[61];<BR>/*20*/  char unknown1[20];		// Placeholder<BR>// Correct Order: str, sta, wis, dex, agi, cha, int<BR>/*21*/  char STR;			// Strength<BR>/*22*/  char STA;			// Stamina<BR>/*23*/  char WIS;			// Wisdom<BR>/*24*/  char DEX;			// Dexterity<BR>/*25*/  char AGI;			// Agility<BR>/*26*/  char CHA;			// Charisma<BR>/*27*/  char INT;			// Intelligence<BR>/*28*/  char MR;			// Magic Resistance<BR>/*29*/  char FR;			// Fire Resistance<BR>/*30*/  char CR;			// Cold Resistance<BR>/*31*/  char DR;			// Disease Resistance<BR>/*32*/  char PR;			// Poison Resistance<BR>/*33*/  char HP;			// Hitpoints<BR>/*34*/  char MANA;			// Mana<BR>/*35*/  char AC;			// Armor Class<BR>/*37*/  char unknown2[2];		// Placeholder<BR>/*38*/  UBYTE light;			// Light effect of this item<BR>/*39*/  char delay;			// Weapon Delay<BR>/*41*/  char damage;			// Weapon Damage<BR>/*41*/  char unknown6;		// Placeholder<BR>/*42*/  UBYTE range;			// Range of weapon<BR>/*43*/  UBYTE skill;			// Skill of this weapon<BR>/*44*/  char magic;			// Magic flag, 0(0000=unique?, 1(0001)=magic, 12(1100)=meat?, 14(1110)=normal?, 15(1111)=???<BR>/*45*/  char level0;			// Casting level<BR>/*46*/  UBYTE material;		// Material?<BR>/*48*/  char unknown3_[2];		// Placeholder<BR>/*52*/  UDWORD color;			// Amounts of RGB in original color <BR>/*53*/  char unknown3__[2];		// Placeholder<BR>/*56*/  UWORD spellId0;		// SpellID of special effect<BR>/*58*/  UWORD classes;		// Classes that can use this item (this is not exactly)<BR>/*60*/  UWORD races;			// Races that can use this item(like items)<BR>/*61*/  char unknown15;		// Placeholder<BR>  char numSlots;		// number of slots in bag.<BR>  char unknown16;               // more padding.<BR>  UBYTE level;			// Casting level<BR>  char number;			// Number of items in stack<BR>  char unknown8;		// Placeholder<BR>  UWORD spellId;		// spellId of special effect<BR>};<P>/* Server System Message */<BR>struct systemMessageStruct<BR>{<BR>  char opCode;			// Always 0xa4<BR>  char version;			// 0x21<BR>  char message[0];		// Variable length message<BR>};<P>/* Spawn HP Update */<BR>struct spawnHpUpdateStruct<BR>{<BR>  char opCode;			// Always 0x75<BR>  char version;			// 0x20<BR>  UWORD spawnId;			// Id of spawn to update<BR>  WORD unknown0;		// Placeholder<BR>  WORD curHp;			// Current hp of spawn<BR>  WORD unknown1;		// Placeholder<BR>  WORD maxHp;			// Maximum hp of spawn<BR>  WORD unknown2;		// Placeholder<BR>};<P>/* Spawn Position Update */<BR>struct spawnPositionUpdateStruct<BR>{<BR>  char opCode;			// Was 0x85, now 0xa1 <BR>  char version;			// 0x20<BR>  DWORD numUpdates;		// Number of SpawnUpdates<BR>  struct<BR>  {<BR>    UWORD spawnId;		// Id of spawn to update  <BR>    char unknown0[1];		// Placeholder<BR>    char heading;		// Heading<BR>    char deltaHeading;		// Heading Change<BR>    WORD yPos;			// New Y position of spawn<BR>    WORD xPos;			// New X position of spawn<BR>    WORD zPos;			// New Z position of spawn<BR>    DWORD deltaY:10,		// Velocities <BR>         spacer1:1,<BR>         deltaZ:10,		//  Velocity<BR>         spacer2:1,<BR>         deltaX:10;		//  Velocity<BR>  }<BR>  spawnUpdate[0];		// Variable number of updates<P>};<P>/* Player Update Packet */<BR>struct playerUpdateStruct<BR>{<BR>  char opCode;			// Always 0xd1<BR>  char version;			// 0x20<BR>  UWORD spawnId;		// Id of player  <BR>  char unknown0[1];		// Placeholder<BR>  char heading;			// Current heading of player<BR>  char deltaHeading;		// Heading Change<BR>  WORD yPos;			// Players Y Position<BR>  WORD xPos;			// Players X Position<BR>  WORD zPos;			// Players Z Position<BR>  DWORD deltaY:10,		// Velocities <BR>        spacer1:1,<BR>        deltaZ:10,		//  Velocity<BR>        spacer2:1,<BR>        deltaX:10;		//  Velocity<BR>};<P>#define LIST_HP 0<BR>#define LIST_MANA 1<BR>#define LIST_STAM 2<BR>#define LIST_EXP 3<BR>#define LIST_FOOD 4<BR>#define LIST_WTR 5<BR>#define LIST_STR 6<BR>#define LIST_STA 7<BR>#define LIST_CHA 8<BR>#define LIST_DEX 9<BR>#define LIST_INT 10<BR>#define LIST_AGI 11<BR>#define LIST_WIS 12<BR>#define LIST_MR 13<BR>#define LIST_FR 14<BR>#define LIST_CR 15<BR>#define LIST_DR 16<BR>#define LIST_PR 17<BR>#define LIST_AC 18<BR>#define LIST_MAXLIST 19<P>/* Player Profile */<BR>struct playerProfileStruct<BR>{<BR>/*00*/  char opCode;			// Was 0x35, now 0x3D <BR>/*01*/  char version;			// 0x21<BR>/*02*/  char unknown0[4];		// Placeholder<BR>/*06*/  char name[30];		// Name of player<BR>/*36*/  char lastName[20];		// Last name of player<BR>/*56*/  WORD unknown5;		// Placeholder<BR>/*58*/  UBYTE race;			// Player race<BR>/*59*/  char unknown1;		// Placeholder<BR>/*60*/  UBYTE class_;			// Player class<BR>/*61*/  UBYTE gender;			// Player gender<BR>/*62*/  UBYTE level;			// Level of player (might be one byte)<BR>/*63*/  char unknown2[3];		// Placeholder<BR>/*66*/  UDWORD exp;			// Current Experience<BR>/*70*/  WORD unknown7;<BR>/*72*/  WORD MANA;		// MANA<BR>/*74*/  char unknown6[51];<BR>// Correct Order: str, sta, wis, dex, agi, cha, int<BR>/*125*/  char STR;			// Strength<BR>/*126*/  char STA;			// Stamina<BR>/*127*/  char WIS;			// Wisdom<BR>/*128*/  char DEX;			// Dexterity<BR>/*129*/  char AGI;			// Agility<BR>/*130*/  char CHA;			// Charisma<BR>/*131*/  char INT;			// Intelligence<BR> char unknown4[2378];		// Placeholder<BR>  unsigned char skills[74];	// List of skills<BR>  char unknown3[1950];<BR>};<P>/* Zone Spawns */<BR>struct zoneSpawnsStruct<BR>{<BR>  char opCode;			// Always 0x47<BR>  char version;			// 0x21<BR>  DWORD unknown1;<BR>  struct spawnStruct spawn[0];	// Variable number of spawns<BR>};<P>/* Client Zone Entry struct - opcode 0x2A20 */  <BR>struct ClientZoneEntryStruct<BR>{<BR>  char opCode;                  // Always 0x2a<BR>  char version;                 // 0x20<BR>  DWORD unknown1;<BR>  char name[20];                // Player firstname<BR>  DWORD unknown2;<BR>  DWORD unknown3;<BR>  DWORD unknown4;<BR>};<P>/* New Zone Name */<BR>struct newZoneStruct<BR>{<BR>  char opCode;			// Was 0xcb, now now 0x5b<BR>  char version;			// 0x20<BR>  char unknown0[30];		// Placeholder<BR>  char shortName[15];<BR>  char unknown1[5];		// Placeholder<BR>  char longName[15];<BR>};<P>/* Door */<BR>struct newDoorStruct<BR>{<BR>  char opCode;			// Always 0x94<BR>  char version;			// 0x20<BR>  char name[8];			// Filename of Door?<BR>  char unknown[40];		// Placeholder<BR>};<P>/* Special Message */<BR>struct spMesgStruct<BR>{<BR>  char opCode;			// Always 0x80<BR>  char version;			// 0x21<BR>  DWORD msgType;		// Type of message<BR>  char message[0];		// Message, followed by four 0 bytes?<BR>};<P>/* Reading a book */<BR>struct bookTextStruct<BR>{<BR>  char opCode;			// Always 0x59<BR>  char version;			// 0x20<BR>  char text[0];			// Text of item reading<BR>};<P>/* Emote text */<BR>struct emoteTextStruct<BR>{<BR>  char opCode;			// Always 0x15<BR>  char version;			// 0x20<BR>  char text[0];			// Text of item reading<BR>};<P><BR>/* Level up */<BR>struct levelUpStruct<BR>{<BR>  char opCode;			//Always 0x86<BR>  char version;			// 0x21<BR>  UDWORD level;			// New level <BR>  UDWORD levelOld;		// Old level <BR>  UDWORD exp;			// Current Experience <BR>};<P>/* Exp update */<BR>struct expUpdateStruct<BR>{<BR>  char opCode;			//Always 0x87<BR>  char version;			// 0x21<BR>  UDWORD exp;			// Current experience value<BR>};<P>/* Time of Day ? */<BR>struct timeOfDayStruct<BR>{<BR>  WORD opcode;			// F220<BR>  char hour;			// 1-24<BR>  char minute;			// 0-59<BR>  char day;				// 1-28<BR>  char month;			// 1-12<BR>  UWORD year;			// year<BR>};<P>struct skillIncreaseStruct<BR>{<BR>  char opCode;			// Always 0x92<BR>  char version;			// 0x20<BR>  WORD skillId;			// Id of skill<BR>  char unknown0[2];		// Placeholder<BR>  WORD value;			// New value of skill<BR>  char unknown1[2];		// New value of skill<BR>};<P>/* Memorize slot operations, mem, forget, etc */<BR>struct memorizeSlotStruct<BR>{<BR>  char opCode;			// Always 0x82<BR>  char version;			// 0x21<BR>  char slot;			// Memorization slot (0-7)<BR>  char unknown0[3];		// Placeholder<BR>  UWORD spellId;		// Id of spell (offset of spell in spdat.eff)<BR>  char unknown1[6];		// Placeholder 00,00,01,00,00,00<BR>};<P>/* Begin Casting */<BR>struct beginCastStruct<BR>{<BR>  char opCode;			// Was 0x7d, now 0xb2 (untested)<BR>  char version;			// 0x20<BR>  UWORD spawnId;		// Id of who is casting<BR>  WORD unknown0;		// Placeholder<BR>  UWORD spellId;		// Id of spell<BR>  WORD param1;			// Paramater 1?<BR>  WORD param2;			// Paramater 2?<BR>  WORD param3;			// Parameter 3?<BR>};<P>/* Interrupted Casting */<BR>struct interruptCastStruct<BR>{<BR>  char opCode;			// Always 0xd3<BR>  char version;			// 0x21<BR>  UWORD spawnId;		// Id of who is casting<BR>  WORD unknown0;		// Placeholder<BR>  char message[0];<BR>};<P>/* Kill something */<BR>struct spawnKilledStruct<BR>{<BR>  char opCode;			// Always 0x4a<BR>  char verison;			// 0x20<BR>  UWORD spawnId;			// Id of spawn that died<BR>  //From wizzie Wiz:<BR>  WORD unknown0;<BR>  UWORD killerId;<BR>  char unknown1[10];<BR>};<P>/*When somebody changes what they're wearing or give a pet a weapon (model changes)*/<BR>struct wearChangeStruct{<BR>    WORD opCode; //9220<BR>    UWORD spawnId;<BR>    char unknown0[2];<BR>    unsigned char wearSlotId;<BR>    unsigned char newItemId;<BR>    char unknown1[6];  //first few bytes react to clothing changes<BR>};<P>struct dropThingOnGround{<BR>/*000*/WORD opCode; //3520<BR>/*002*/unsigned char unknown0a[8]; //working.<BR>/*002*/UWORD itemNr; <BR>/*002*/unsigned char unknown0b[2]; //working.<BR>/*00E*/UWORD dropId;<BR>/*010*/unsigned char unknown2[26];<BR>/*02A*/float yPos;<BR>/*02E*/float xPos;<BR>/*032*/float zPos;<BR>/*010*/unsigned char unknown3[4];<BR>/*0XX*/char idFile[16];//maybe be 4?<BR>/*0XX*/unsigned char unknown4[168];<P>};<P>struct removeThingOnGround{<BR>    WORD opCode; //3620<BR>    UWORD dropId; //guess<BR>    char unknown0[6];  //shrug<BR>};<P><BR>struct castOnStruct<BR>{<BR>  char opCode;//0x4620<BR>  char version; <BR>  UWORD targetId;<BR>  char unknown0[2];<BR>  UWORD sourceId;<BR>  char unknown1[26];  // might be some spell info?<BR>};<P>struct manaDecrementStruct<BR>{<BR>  WORD opCode;//0x7f21<BR>  WORD newMana; // ammount of mana left after cast<BR>  WORD spellID; <BR>};<P>struct summonedItemStruct<BR>{<BR>  char opCode; // 0x78<BR>  char version; // 0x21<BR>  struct itemStruct item;<BR>};<P>struct tradeItemStruct<BR>{<BR>  char opCode; // 0xdf<BR>  char version; // 0x20<BR>  char unknown[6];<BR>  char itemtype;<BR>  struct itemStruct item;<BR>};<P>struct staminaStruct {<BR>  char opCode; // 0x57<BR>  char version; // 0x21<BR>  WORD food; // (low numbers are more hungry 127-0)<BR>  WORD water; // (low numbers are more thirsty 127-0)<BR>  WORD fatigue; // (high numbers are more fatigued 0-100)<BR>};<P>// Supplied by Sparr:  Somone give this guy write rights =)<P>struct dropCoinsStruct{<BR>  WORD opCode; //0720<BR>  unsigned char unknown1[24]; //no clue<BR>  UWORD dropId;<BR>  unsigned char unknown2[22];<BR>  UDWORD amount;<BR>  unsigned char unknown3[4];<BR>  float yPos;<BR>  float xPos;<BR>  float zPos;<BR>  unsigned char unknown4[12]; //blank space<BR>  char type[15]; //silver gold whatever<BR>  unsigned char unknown5[17];<BR>};<P>struct removeCoinsStruct{<BR>  WORD opCode; //0820<BR>  UWORD dropId; //guess<BR>  char unknown0[6];  //shrug<BR>};<P>/*<BR>** Structure that informs the client about spells/fighting going<BR>** around it<BR>*/<P>struct actionStruct {<BR>	WORD opCode;		// 5820<BR>	UWORD target;<BR>	char unknown1[2];<BR>	UWORD source;<BR>	char unknown2[2];<BR>	char type;			// Casts, Falls, Bashes, etc...?<BR>	char unknown3;<BR>	WORD spell;<BR>	DWORD damage;<BR>	char unknown4[6];<BR>	DWORD range;<BR>	char unknwon5[2];<P>};<P><BR>struct attack1Struct{<BR>  WORD opCode; //f520<BR>  UWORD spawnId;<BR>  WORD unknown1;<BR>  WORD unknown2;<BR>  WORD unknown3;<BR>  WORD unknown4;<BR>  WORD unknown5;<BR>};<P>struct attack2Struct{<BR>  WORD opCode; //9f20<BR>  UWORD spawnId;<BR>  WORD unknown1;<BR>  WORD unknown2;<BR>  WORD unknown3;<BR>  WORD unknown4;<BR>  WORD unknown5;<BR>};<P>struct considerStruct{ <BR>  WORD opcode;        /*3721*/ <BR>  UWORD playerid; <BR>  char unknown1[2];<BR>  UWORD targetid; <BR>  char unknown2[2]; <BR>  DWORD faction;<BR>  DWORD level;<BR>  DWORD curHp; <BR>  DWORD maxHp;<BR>};<P>struct newGuildInZoneStruct {<BR>  WORD opcode; /*7b21*/<BR>  char unknown[8];<BR>  char guildname[56]; <BR>};<P>struct moneyUpdateStruct{<BR>  WORD opcode; /*3d21*/<BR>  UWORD unknown1;<BR>  char unknown2[2];<BR>  unsigned char cointype;<BR>  char unknown3[3];<BR>  UDWORD amount; <BR>};<P>struct bindWoundStruct{<BR>  WORD opcode; /*8321*/<BR>  UWORD playerid;<BR>  char unknown1[2];<BR>  DWORD hpmaybe;<BR>};<P>struct inspectedStruct{<BR>  WORD opcode; /*bf20*/<BR>  UWORD inspectorid;<BR>  unsigned char blank1[2];<BR>  UWORD inspectedid; /*should be you*/<BR>  unsigned char blank2[2];<BR>};<P>struct inspectingStruct{<BR>  WORD opcode; //B620<BR>  char unknown1[40];<BR>  char itemNames[21][32];//21 items with names 32 characters long.<BR>  UWORD icons[21];  <BR>  char unknown2[2];<BR>  char mytext[200];<BR>  char unknown3[88];<P>};<P>struct randomStruct {<BR>  WORD opcode; /* e7 21 */<BR>  UDWORD bottom; /* Bottom number for random request */<BR>  UDWORD top; /* Top number for random request */<BR>};<P>struct groupMemberStruct {<BR>  WORD opcode; /*26 40*/<BR>  char yourname[32];<BR>  char membername[32];<BR>  char unknown1[35];<BR>  char bgARC;//Add = 2, Remove = 3, Clear = 0- Bad Guess-ATB<BR>  char unknown2[83];<BR>  char ARC;//Add = 4, Remove = 3<BR>  char ARC2;//?? -  Add = c8, remove 1 = c5, clear = 01 <BR>  char unknown3[131];//what does this stuff MEAN?<BR>};<P>#endif // EQSTRUCT_H<P>//. .7...6....,X....D4.M.\.....P.v..&gt;..W....<BR>//123456789012345678901234567890123456789012<BR>//000000000111111111122222222223333333333444<BR>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /*<BR> * experiencelog.cpp<BR> *<BR> * ShowEQ Distributed under GPL<BR> * http://www.hackersquest.gomp.ch/<BR> */<P>#include "experiencelog.h"<BR>#include "interface.h"<BR>#include "util.h"<P>#include &lt;qgrid.h&gt;<BR>#include &lt;qtimer.h&gt;<BR>#include &lt;qhbox.h&gt;<BR>#include &lt;qvgroupbox.h&gt;<BR>#include &lt;qmessagebox.h&gt;<BR>#include &lt;stdio.h&gt;<BR>#define DEBUG<P>#undef DEBUG<P>ExperienceRecord::ExperienceRecord( const QString &mob_name, int mob_level,<BR>   long xp_gained, time_t time, const QString &zone_name, EQPacket *p) :<P>   m_mob_name( mob_name ),<BR>   m_mob_level( mob_level ),<BR>   m_xp_gained( xp_gained ),<BR>   m_time( time ), <BR>   m_zone_name( zone_name ), <BR>   m_packet ( p ) {<P>}<P>const QString &ExperienceRecord::getMobName() const {<P>   return m_mob_name;<P>}<P>int ExperienceRecord::getMobLevel() const {<P>   return m_mob_level;<P>}<P>long ExperienceRecord::getExpGained() const {<P>   return m_xp_gained;<P>}<P>long ExperienceRecord::getExpValue() const {<P>   // TODO: This isn't right for all mob levels!<BR>   //     But casey's working on it!<BR>   return m_mob_level*m_mob_level*75;<BR>}<P>long ExperienceRecord::getExpValueZEM() const {<P>   EQInterface *m_pParent = (EQInterface*)m_packet-&gt;m_pParent;<BR>   int ZEM = m_pParent-&gt;getmap()-&gt;getZEM();<BR>   return m_mob_level*m_mob_level*ZEM;<BR>}<BR> <BR>long ExperienceRecord::getExpValuep() const {<P>   int p_penalty; <BR>   // WAR and ROG are at 10 since thier EXP is not scaled to compensate<BR>   // for thier bonus<BR>   switch (m_packet-&gt;getplayer()-&gt;getPlayerClass())<BR>   {<BR>      case 1 : p_penalty = 10; break; // WAR<BR>      case 2 : p_penalty = 10; break; // CLR<BR>      case 3 : p_penalty = 14; break; // PAL<BR>      case 4 : p_penalty = 14; break; // RNG<BR>      case 5 : p_penalty = 14; break; // SHD<BR>      case 6 : p_penalty = 10; break; // DRU<BR>      case 7 : p_penalty = 12; break; // MNK<BR>      case 8 : p_penalty = 14; break; // BRD<BR>      case 9 : p_penalty = 10; break; // ROG<BR>      case 10: p_penalty = 10; break; // SHM<BR>      case 11: p_penalty = 11; break; // NEC<BR>      case 12: p_penalty = 11; break; // MAG<BR>      case 13: p_penalty = 11; break; // ENC<BR>      default: /* why are we here? */<BR>         p_penalty = 10; break; <BR>   }<BR>   int baseExp = getExpValueZEM();<BR>   return (int)((float)baseExp*((float)p_penalty/(float)10));<BR>}<P>long ExperienceRecord::getExpValueg() const {<P>   int pExp = getExpValuep();<BR>   int gbonus;<BR>   int myLevel = m_packet-&gt;getplayer()-&gt;getPlayerLevel();<BR>   int i, group_ag=myLevel;<BR>   /* groupSize is in addition to yourself 5==full group */<BR>   switch (m_packet-&gt;groupSize) {<BR>      case 0: gbonus = 100; break;<BR>      case 1: gbonus = 102; break;<BR>      case 2: gbonus = 106; break;<BR>      case 3: gbonus = 110; break;<BR>      case 4: gbonus = 114; break;<BR>      case 5: gbonus = 120; break;<BR>      default: gbonus = 100; break;<BR>   }<BR>   /* calculate group aggregate level */<BR>   EQInterface *m_pParent = (EQInterface*)m_packet-&gt;m_pParent;<BR>   spawnStruct * m_pGroupie;<BR>   printf("GROUPSIZE: %d\n", m_packet-&gt;groupSize);<BR>   for (i=0; i &lt; m_packet-&gt;groupSize; i++)<BR>   {<BR>      group_ag += m_packet-&gt;groupLevels[i];<BR>      printf("GROUPMEMBER %d, level %d\n", m_packet-&gt;groupID[i], m_packet-&gt;groupLevels[i]);<BR>   }<BR>   printf("MY Level: %d\n GroupTot: %d\n BONUS   :%d\n", myLevel, group_ag, gbonus);<BR>   return (int) (((float)pExp)*((float)gbonus/(float)100)*((float)myLevel/(float)group_ag));<BR>}<P>time_t ExperienceRecord::getTime() const {<P>   return m_time;<P>}<P>const QString &ExperienceRecord::getZoneName() const {<P>   return m_zone_name;<P>}<P>ExperienceWindow::ExperienceWindow( EQPacket *p ) : m_packet( p ) {<P>  /* Hopefully this is only called once to set up the window,<BR>     so this is a good place to initialize some things which<BR>     otherwise won't be. */<BR>  p-&gt;maxExp = 0;<BR>  p-&gt;currentExp = 0;<P>   m_ratio = 1;<BR>   m_timeframe = 0;<BR>   m_calcZEM=0;<BR>   m_ZEMviewtype = 0;<BR>   m_view_menu = new QPopupMenu( this );<P>   m_view_menu-&gt;insertItem( "&All Mobs", this, SLOT(viewAll()) );<BR>   m_view_menu-&gt;insertItem( "Previous &15 Minutes", this,<BR>      SLOT(view15Minutes()) );<BR>   m_view_menu-&gt;insertItem( "Previous &30 Minutes", this,<BR>      SLOT(view30Minutes()) );<BR>   m_view_menu-&gt;insertItem( "Previous &60 Minutes", this,<BR>      SLOT(view60Minutes()) );<BR>   m_view_menu-&gt;setItemChecked( m_view_menu-&gt;idAt(0), true );<P>   m_view_menu-&gt;insertSeparator();<P>   m_exp_rate_menu = new QPopupMenu( this );<BR>   m_exp_rate_menu-&gt;insertItem( "per &minute", this,<BR>      SLOT(viewRatePerMinute()) );<BR>   m_exp_rate_menu-&gt;insertItem( "per &hour", this, SLOT(viewRatePerHour()) );<BR>   m_exp_rate_menu-&gt;setItemChecked( m_exp_rate_menu-&gt;idAt(0), true );<P>   m_view_menu-&gt;insertItem( "Experience &Rate", m_exp_rate_menu );<P>   m_view_menu-&gt;insertSeparator();<P>   m_view_menu-&gt;insertItem( "Clear", this, SLOT(viewClear()) );<P>   m_view_menu-&gt;insertSeparator();<P>   m_view_menu-&gt;insertItem( "Calculate ZEM on next kill", this, SLOT(calcZEMNextKill()) );<P>   m_ZEM_menu = new QPopupMenu( this );<BR>   m_ZEM_menu-&gt;insertItem( "Calculated Value", this, SLOT(viewZEMcalculated()) );<BR>   m_ZEM_menu-&gt;insertItem( "Raw Value", this, SLOT(viewZEMraw()) );<BR>   m_ZEM_menu-&gt;insertItem( "Percent Bonus", this, SLOT(viewZEMpercent()) );<BR>   m_ZEM_menu-&gt;setItemChecked( m_ZEM_menu-&gt;idAt(0), true );<P>   m_view_menu-&gt;insertItem( "ZEM View Options", m_ZEM_menu );<P>   m_menu_bar = new QMenuBar( this );<P>   m_menu_bar-&gt;insertItem( "&View", m_view_menu );<P>   m_layout = new QVBoxLayout( this );<BR>   m_layout-&gt;addSpacing( m_menu_bar-&gt;height() + 5 );<P>   QGroupBox *listGBox = new QVGroupBox( "Experience Log", this );<BR>   m_layout-&gt;addWidget( listGBox );<P>   m_exp_listview = new QListView(listGBox);<BR>   m_exp_listview-&gt;addColumn("Time");<BR>   m_exp_listview-&gt;addColumn("Mob");<BR>   m_exp_listview-&gt;addColumn("Level");<BR>   m_exp_listview-&gt;addColumn("Base Exp");<BR>   m_exp_listview-&gt;addColumn("ZEM total");<BR>   m_exp_listview-&gt;addColumn("Class total");<BR>   m_exp_listview-&gt;addColumn("Group total");<BR>   m_exp_listview-&gt;addColumn("Experience Gained");<BR>   <BR>   m_exp_listview-&gt;setMinimumSize( m_exp_listview-&gt;sizeHint().width(),<BR>      200 );<P>   QGroupBox *statsGBox = new QVGroupBox( "Statistics", this );<BR>   m_layout-&gt;addWidget( statsGBox );<BR>   <BR>   QGrid *statsGrid = new QGrid( 4, statsGBox );<P>   QLabel *total_label = new QLabel( "Total Experience Received:",<BR>      statsGrid );<BR>   m_total_received = new QLabel( statsGrid );<P>   QLabel *play_time = new QLabel( "Play Time:", statsGrid );<BR>   m_play_time = new QLabel( statsGrid );<P>   QLabel *mob_count = new QLabel( "Total Mobs Killed:", statsGrid );<BR>   m_mob_count = new QLabel( statsGrid );<P>   m_experience_rate_label = new QLabel( "Experience Rate (per minute):", statsGrid );<BR>   m_experience_rate = new QLabel( statsGrid );<P>   QLabel *average_per_mob = new QLabel( "Average Experience per Mob:",<BR>      statsGrid );<BR>   m_average_per_mob = new QLabel( statsGrid );<P>   QLabel *kills_to_level = new QLabel( "Estimated Kills To Level:",<BR>      statsGrid );<BR>   m_kills_to_level = new QLabel( statsGrid );<P>   QLabel *experience_remaining = new QLabel( "Experience Remaining:",<BR>      statsGrid );<BR>   m_experience_remaining = new QLabel( statsGrid );<P>   QLabel *time_to_level = new QLabel( "Estimated Time To Level:",<BR>      statsGrid );<BR>   m_time_to_level = new QLabel( statsGrid );<P>   // ewww, why can't we just get it from QGrid?  <IMG SRC="http://www.ethernalquest.com/ubb/frown.gif"><BR>   ((QGridLayout *)statsGrid-&gt;layout())-&gt;setColStretch( 1, 1 );<BR>   ((QGridLayout *)statsGrid-&gt;layout())-&gt;setColStretch( 3, 1 );<BR>   statsGrid-&gt;layout()-&gt;setSpacing( 5 );<P>   updateAverage( );<P>   // timer to update the average xp<BR>   QTimer *timer = new QTimer( this );<BR>   connect( timer, SIGNAL(timeout()), SLOT(updateAverage()));<BR>   timer-&gt;start(15*1000); // calculate every 15 seconds<P>//   setMinimumSize( sizeHint() );<P>}<P>void ExperienceWindow::addExpRecord( const QString &mob_name,<BR>   int mob_level, long xp_gained, QString zone_name ) {<P>   ExperienceRecord *xp = new ExperienceRecord( mob_name, mob_level,<BR>      xp_gained, time(0), zone_name, m_packet );<P>#ifdef DEBUG<BR>   resize( sizeHint() );<BR>  qDebug("ExperienceWindow::addExpRecord()  '%s', lvl %d, exp %d",<BR>      mob_name.ascii(), mob_level, xp_gained);<BR>#endif<P>   m_exp_list.append( xp );<P>   // convert everything to string representations for the list view<BR>   QString s_mob_name = mob_name;<BR>   QString s_mob_level;<BR>   s_mob_level.setNum(mob_level);<BR>   QString s_xp_gained;<BR>   s_xp_gained.setNum(xp_gained);<BR>   QString s_xp_value;<P>   if (m_calcZEM)<BR>   {<BR>      calculateZEM(xp_gained, mob_level);<BR>      m_calcZEM = 0;<BR>      m_view_menu-&gt;setItemChecked(m_view_menu-&gt;idAt(9), false);<BR>   }   <BR>   s_xp_value.setNum(xp-&gt;getExpValue());<BR>   QString s_xp_valueZEM;<BR>   EQInterface *m_pParent = (EQInterface*)m_packet-&gt;m_pParent;<BR>   switch (m_ZEMviewtype) {<BR>      case 1 : s_xp_valueZEM.setNum(m_pParent-&gt;getmap()-&gt;getZEM()); break;<BR>      case 2 : s_xp_valueZEM.setNum(((float)(m_pParent-&gt;getmap()-&gt;getZEM()-75)/(float)75)*100);<BR>         break;<BR>      default: s_xp_valueZEM.setNum(xp-&gt;getExpValueZEM()); break;<BR>   }<BR>   QString s_xp_valuep;<BR>   s_xp_valuep.setNum(xp-&gt;getExpValuep());<BR>   QString s_xp_valueg;<BR>   s_xp_valueg.setNum(xp-&gt;getExpValueg());<P>   char s_time[64];<BR>   time_t timev = xp-&gt;getTime();<BR>   strftime(s_time, 64, "%m/%d %H:%M:%S", localtime( &timev ));<P>   /* Update suggested by Shag */<BR>   QListViewItem *new_exp_entry = <BR>     new QListViewItem( m_exp_listview, s_time, s_mob_name, <BR>			s_mob_level, s_xp_value, s_xp_valueZEM,<BR>			s_xp_valuep, s_xp_valueg, s_xp_gained );<P>   m_exp_listview-&gt;insertItem( new_exp_entry );<BR>   m_exp_listview-&gt;setSelected( new_exp_entry, TRUE );<BR>   m_exp_listview-&gt;ensureItemVisible( new_exp_entry );<P>   // and update the average display<BR>   updateAverage();<P>}<P>void ExperienceWindow::updateAverage( ) {<P>   static bool force = true;<P>   // don't worry about updating the window if it's not even visible,<BR>   // unless <BR>   if ( !force && !isVisible() )<BR>      return;<P>   force = false;<P>   // calculate the earliest time to accept<BR>   time_t time_cutoff = 0;<BR>   double total_exp = 0;<P>   if (m_timeframe)<BR>      time_cutoff = time(0) - (m_timeframe*60);<P>   // start at the end, add up the xp & mob count until we hit the<BR>   // beginning of list<BR>   // or the time cutoff<BR>   QListIterator&lt;ExperienceRecord&gt; it(m_exp_list);<P>   int mob_count = 0;<BR>   time_t first_kill_time = 0;<P>   it.toLast();<BR>   while ( it.current() && it.current()-&gt;getTime() &gt;= time_cutoff ) {<P>      total_exp+=it.current()-&gt;getExpGained();<BR>      mob_count++;<P>      if ( it.current()-&gt;getTime() &lt; first_kill_time &#0124;&#0124; !first_kill_time )<BR>         first_kill_time = it.current()-&gt;getTime();<P>      --it;<BR>   }<P>   // calculate the number of minutes that have passed<BR>   double minutes = ( time(0) - first_kill_time ) / 60;<BR>      <BR>   if (!first_kill_time &#0124;&#0124; minutes &lt; 1)<BR>      minutes = 0;<P>   // calculate and display the averages<BR>   QString s_avg_exp;<BR>   QString s_play_time;<BR>   double avg_exp;<P>   if (!m_timeframe) {<BR>      avg_exp = ( minutes ? total_exp/minutes : 0 );<BR>      s_avg_exp=Commanate( (UDWORD)(avg_exp * m_ratio) );<BR>      s_play_time.setNum( minutes );<BR>      s_play_time+=" min";<BR>   } else {<BR>      avg_exp = total_exp/m_timeframe;<BR>      s_avg_exp=Commanate( (UDWORD)(avg_exp * m_ratio) );<BR>      s_play_time.setNum( m_timeframe );<BR>      s_play_time+=" min";<BR>   }<BR>      <BR>   if (m_ratio == 1)<BR>      m_experience_rate_label-&gt;setText( "Experience Rate (per minute):" );<BR>   else if (m_ratio == 60)<BR>      m_experience_rate_label-&gt;setText( "Experience Rate (per hour):" );<P>   QString s_total_exp;<BR>   s_total_exp=Commanate( (UDWORD)total_exp );<P>   QString s_mob_count;<BR>   s_mob_count.setNum( (UDWORD)mob_count );<BR>   <BR>   QString s_mob_avg_exp;<BR>   if (mob_count)<BR>      s_mob_avg_exp=Commanate( (UDWORD)(total_exp/mob_count) );<BR>   else<BR>      s_mob_avg_exp="0";<P>   int exp_remaining;<P>   if ( (m_packet-&gt;maxExp &gt; m_packet-&gt;currentExp) && (m_packet-&gt;currentExp &gt; 0) ) {<BR>     /* since currentExp is calculated before maxExp when the decoder<BR>	is broken, sometimes maxExp ends up set to zero or undefined.<BR>	This can result in strange exp_remaining values, so some sanity<BR>	checks have been added.  cpphack */<BR>     exp_remaining = m_packet-&gt;maxExp - m_packet-&gt;currentExp;<BR>   } else {<BR>     exp_remaining = 0;<BR>   }<P>   QString s_exp_remaining;<P>   /* This now checks if the exp value is sensible, and if not<BR>      it is displayed as "unknown". cpphack */<BR>   if (exp_remaining &gt; 0) {<BR>     s_exp_remaining=Commanate( exp_remaining );<BR>   } else {<BR>     s_exp_remaining="unknown";<BR>   }<P>   QString s_kills_to_level;<BR>   if (mob_count)<BR>      s_kills_to_level.setNum( exp_remaining / (total_exp/mob_count) );<BR>   else<BR>      s_kills_to_level="unknown";<P>   int time_to_level = (int)(exp_remaining / avg_exp);<BR>   QString s_time_to_level;<P>   if ( avg_exp ) {<BR>      if (time_to_level &gt; 120)<BR>         s_time_to_level = QString("%1 hours, %2 minutes")<BR>            .arg( (int)(time_to_level/60)).arg( time_to_level % 60 );<BR>      else if (time_to_level &gt; 60)<BR>         s_time_to_level = QString("1 hour, %2 minutes")<BR>            .arg( time_to_level % 60 );<BR>      else<BR>         s_time_to_level = QString("%1 minutes").arg( (int)time_to_level );<BR>   } else<BR>      s_time_to_level="unknown";<P>   m_total_received-&gt;setText( s_total_exp );<BR>   m_mob_count-&gt;setText( s_mob_count );<BR>   m_average_per_mob-&gt;setText( s_mob_avg_exp );<BR>   m_experience_remaining-&gt;setText( s_exp_remaining );<BR>   <BR>   m_play_time-&gt;setText( s_play_time );<BR>   m_experience_rate-&gt;setText( s_avg_exp );<BR>   m_kills_to_level-&gt;setText( s_kills_to_level );<BR>   m_time_to_level-&gt;setText( s_time_to_level );<P>}<P>void ExperienceWindow::resizeEvent ( QResizeEvent *e ) {<P>   int mh = m_menu_bar-&gt;height() + 4;<P>   //m_layout-&gt;setGeometry( 0, mh, e-&gt;size().width(),  e-&gt;size().height()-mh );<P>}<P>void ExperienceWindow::viewAll() {<P>   m_timeframe = 0;<BR>   updateAverage();<BR>   m_view_menu-&gt;setItemChecked(m_view_menu-&gt;idAt(0), true);<BR>   m_view_menu-&gt;setItemChecked(m_view_menu-&gt;idAt(1), false);<BR>   m_view_menu-&gt;setItemChecked(m_view_menu-&gt;idAt(2), false);<BR>   m_view_menu-&gt;setItemChecked(m_view_menu-&gt;idAt(3), false);<P>}<P>void ExperienceWindow::view15Minutes() {<P>   m_timeframe = 15;<BR>   updateAverage();<BR>   m_view_menu-&gt;setItemChecked(m_view_menu-&gt;idAt(0), false);<BR>   m_view_menu-&gt;setItemChecked(m_view_menu-&gt;idAt(1), true);<BR>   m_view_menu-&gt;setItemChecked(m_view_menu-&gt;idAt(2), false);<BR>   m_view_menu-&gt;setItemChecked(m_view_menu-&gt;idAt(3), false);<P>}<P>void ExperienceWindow::view30Minutes() {<P>   m_timeframe = 30;<BR>   updateAverage();<BR>   m_view_menu-&gt;setItemChecked(m_view_menu-&gt;idAt(0), false);<BR>   m_view_menu-&gt;setItemChecked(m_view_menu-&gt;idAt(1), false);<BR>   m_view_menu-&gt;setItemChecked(m_view_menu-&gt;idAt(2), true);<BR>   m_view_menu-&gt;setItemChecked(m_view_menu-&gt;idAt(3), false);<P>}<P>void ExperienceWindow::view60Minutes() {<P>   m_timeframe = 60;<BR>   updateAverage();<BR>   m_view_menu-&gt;setItemChecked(m_view_menu-&gt;idAt(0), false);<BR>   m_view_menu-&gt;setItemChecked(m_view_menu-&gt;idAt(1), false);<BR>   m_view_menu-&gt;setItemChecked(m_view_menu-&gt;idAt(2), false);<BR>   m_view_menu-&gt;setItemChecked(m_view_menu-&gt;idAt(3), true);<P>}<P>void ExperienceWindow::viewRatePerHour() {<P>   m_ratio = 60;<BR>   updateAverage();<BR>   m_exp_rate_menu-&gt;setItemChecked(m_exp_rate_menu-&gt;idAt(0), false);<BR>   m_exp_rate_menu-&gt;setItemChecked(m_exp_rate_menu-&gt;idAt(1), true);<P>}<P>void ExperienceWindow::viewRatePerMinute() {<P>   m_ratio = 1;<BR>   updateAverage();<BR>   m_exp_rate_menu-&gt;setItemChecked(m_exp_rate_menu-&gt;idAt(0), true);<BR>   m_exp_rate_menu-&gt;setItemChecked(m_exp_rate_menu-&gt;idAt(1), false);<P>}<P>void ExperienceWindow::calcZEMNextKill() {<P>   m_calcZEM = 1;<BR>   m_view_menu-&gt;setItemChecked(m_view_menu-&gt;idAt(9), true);<BR>}<P>void ExperienceWindow::viewZEMcalculated() {<P>   m_ZEMviewtype = 0;<BR>   m_ZEM_menu-&gt;setItemChecked(m_ZEM_menu-&gt;idAt(0), true);<BR>   m_ZEM_menu-&gt;setItemChecked(m_ZEM_menu-&gt;idAt(1), false);<BR>   m_ZEM_menu-&gt;setItemChecked(m_ZEM_menu-&gt;idAt(2), false);<P>}<P>void ExperienceWindow::viewZEMraw() {<P>   m_ZEMviewtype = 1;<BR>   m_ZEM_menu-&gt;setItemChecked(m_ZEM_menu-&gt;idAt(0), false);<BR>   m_ZEM_menu-&gt;setItemChecked(m_ZEM_menu-&gt;idAt(1), true);<BR>   m_ZEM_menu-&gt;setItemChecked(m_ZEM_menu-&gt;idAt(2), false);<P>}<P>void ExperienceWindow::viewZEMpercent() {<P>   m_ZEMviewtype = 2;<BR>   m_ZEM_menu-&gt;setItemChecked(m_ZEM_menu-&gt;idAt(0), false);<BR>   m_ZEM_menu-&gt;setItemChecked(m_ZEM_menu-&gt;idAt(1), false);<BR>   m_ZEM_menu-&gt;setItemChecked(m_ZEM_menu-&gt;idAt(2), true);<P>}<P>void ExperienceWindow::viewClear() {<P>   switch( QMessageBox::information( this, "ShowEQ",<BR>      "This function will clear all data listed in the experience "<BR>      "log.  Do you want to continue?",<BR>      "&OK", "&Cancel", QString::null, 1, 1 ) ) {<P>      case 0:<BR>        m_exp_list.clear();<BR>        m_exp_listview-&gt;clear();<BR>        break;<P>      default:<BR>        break;<BR>    }<BR>}<P>void ExperienceWindow::calculateZEM(long xp_gained, int mob_level) {<P>   int gbonus=100;<BR>   int penalty; <BR>   int myLevel = m_packet-&gt;getplayer()-&gt;getPlayerLevel();<BR>   int i, group_ag=myLevel;<BR>   EQInterface *m_pParent = (EQInterface*)m_packet-&gt;m_pParent;<BR>   spawnStruct * m_pGroupie;<BR>   if (m_packet-&gt;groupSize)<BR>   {<BR>      switch (m_packet-&gt;groupSize) {<BR>         case 0: gbonus = 100; break;<BR>         case 1: gbonus = 102; break;<BR>         case 2: gbonus = 106; break;<BR>         case 3: gbonus = 110; break;<BR>         case 4: gbonus = 114; break;<BR>         case 5: gbonus = 120; break;<BR>         default: gbonus = 100; break;<BR>      }<BR>      /* calculate group aggregate level */<BR>      //printf("ZC GROUPSIZE: %d\n", m_packet-&gt;groupSize);<BR>      for (i=0; i &lt; m_packet-&gt;groupSize; i++)<BR>      {<BR>         group_ag += m_packet-&gt;groupLevels[i];<BR>         printf("ZC GROUPMEMBER %d, level %d\n", m_packet-&gt;groupID[i], m_packet-&gt;groupLevels[i]);<BR>      }<BR>      printf("MY Level: %d\n GroupTot: %d\n BONUS   :%d\n", myLevel, group_ag, gbonus);<BR>   }<BR>   // WAR and ROG are at 10 since thier EXP is not scaled to compensate<BR>   // for thier bonus<BR>   switch (m_packet-&gt;getplayer()-&gt;getPlayerClass())<BR>   {<BR>      case 1 : penalty = 10; break; // WAR<BR>      case 2 : penalty = 10; break; // CLR<BR>      case 3 : penalty = 14; break; // PAL<BR>      case 4 : penalty = 14; break; // RNG<BR>      case 5 : penalty = 14; break; // SHD<BR>      case 6 : penalty = 10; break; // DRU<BR>      case 7 : penalty = 12; break; // MNK<BR>      case 8 : penalty = 14; break; // BRD<BR>      case 9 : penalty = 10; break; // ROG<BR>      case 10: penalty = 10; break; // SHM<BR>      case 11: penalty = 11; break; // NEC<BR>      case 12: penalty = 11; break; // MAG<BR>      case 13: penalty = 11; break; // ENC<BR>      default: /* why are we here? */<BR>         penalty = 10; break; <BR>   }<BR>   int ZEM = (int) ((float)xp_gained*((float)((float)group_ag/(float)myLevel)*(float)((float)100/(float)gbonus))*((float)1/(float)(mob_level*mob_level))*((float)10/(float)penalty));<BR>   printf("xpgained: %d\ngroup_ag: %d\nmyLevel: %d\ngbonus: %d\nmob_level: %d\npenalty: %d\n", xp_gained, group_ag, myLevel, gbonus, mob_level, penalty);<BR>   printf("ZEM - ZEM - ZEM ===== %d\n", ZEM);<BR>   m_pParent-&gt;getmap()-&gt;setZEM(ZEM);<BR>}<BR>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /*<BR> * experiencelog.h<BR> *<BR> * ShowEQ Distributed under GPL<BR> * http://www.hackersquest.gomp.ch/<BR> */<P>#ifndef EXPERIENCELOG_H<BR># define EXPERIENCELOG_H<P># include &lt;qobject.h&gt;<BR># include &lt;qwidget.h&gt;<BR># include &lt;qlist.h&gt;<BR># include &lt;qlistview.h&gt;<BR># include &lt;qcombobox.h&gt;<BR># include &lt;qlabel.h&gt;<BR># include &lt;qlayout.h&gt;<BR># include &lt;qmenubar.h&gt;<P># include &lt;sys/time.h&gt;<P>#include "packet.h"<P>class ExperienceRecord {<P>public:<P>   ExperienceRecord( const QString &mob_name, int mob_level, long xp_gained,<BR>      time_t time, const QString &zone_name, EQPacket *p );<P>   const QString &getMobName() const;<BR>   int getMobLevel() const;<BR>   long getExpGained() const;<BR>   long getExpValue() const; // BASE calculated from spawn level<BR>   long getExpValueZEM() const; // calculated from spawn level and ZEM<BR>   long getExpValuep() const; // calculated from spawn level and ZEM + penalty<BR>   long getExpValueg() const; // calculated from spawn level and all + group<BR>   time_t getTime()  const;<BR>   const QString &getZoneName() const;<P>private:<BR>   <BR>   EQPacket *m_packet;<BR>   QString m_zone_name;<BR>   QString m_mob_name;<BR>   int m_mob_level;<BR>   long m_xp_gained;<BR>   time_t m_time;<P>};<P>class ExperienceWindow : public QWidget {<P>   Q_OBJECT<P>public:<P>   ExperienceWindow( EQPacket *p );<P>public slots:<P>   void updateAverage( );<BR>   void addExpRecord( const QString &mob_name, int mob_level, long xp_gained,<BR>      QString zone_name );<BR>   void viewRatePerHour();<BR>   void viewRatePerMinute();<BR>   void viewAll();<BR>   void view15Minutes();<BR>   void view30Minutes();<BR>   void view60Minutes();<BR>   void viewClear();<BR>   void calcZEMNextKill();<BR>   void viewZEMraw();<BR>   void viewZEMpercent();<BR>   void viewZEMcalculated();<P>private:<P>   void resizeEvent( QResizeEvent * );<BR>   void calculateZEM(long xp_gained, int mob_level);<P>   // Need to grab xp totals from here<BR>   EQPacket *m_packet;<P>   QVBoxLayout *m_layout;<P>   QListView *m_exp_listview;<P>   QLabel *m_experience_rate_label;<BR>   QLabel *m_total_received, *m_mob_count, *m_average_per_mob,<BR>      *m_experience_remaining, *m_play_time,<BR>      *m_experience_rate, *m_kills_to_level, *m_time_to_level;<P>   QList&lt;ExperienceRecord&gt; m_exp_list;<P>   QMenuBar *m_menu_bar;<BR>   QPopupMenu *m_view_menu, *m_exp_rate_menu, *m_ZEM_menu;<P>   int m_timeframe;<BR>   int m_ratio;<BR>   int m_calcZEM;<BR>   int m_ZEMviewtype;<P>};<P>#endif // EQINT_H<BR>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /*<BR> * filter.cpp<BR> *<BR> * regex filter module<BR> *<BR> * ShowEQ Distributed under GPL<BR> * http://www.hackersquest.gomp.ch/<BR> */<P>/* Implementation of filter class */<BR>#include &lt;sys/types.h&gt;<BR>#include &lt;stdio.h&gt;<BR>#include &lt;stdlib.h&gt;<BR>#include &lt;string.h&gt;<BR>#include &lt;errno.h&gt;<P>#include "filter.h"<P>//#define DEBUG<P>#undef DEBUG<P>#define MAXLEN   5000<P>/* CRegExp Class - allows easy creation / deletion of regex types */<BR>CRegExp::CRegExp(const char* string, int cflags)<BR>{<BR>  m_pNext = NULL;<BR>  m_pName = strdup(string);<BR>  m_pRegexp = (regex_t *) malloc(sizeof(regex_t));<P>  switch (regcomp(m_pRegexp, string, cflags))<BR>  {<BR>    case 0:	// no error<BR>      break;<BR>    case REG_BADRPT:<BR>      fprintf(stderr, "Filter Error: '%s' - ", string);<BR>      fprintf(stderr, "Invalid use of repetition operators such as using '*' as the first character.\n");<BR>      break;<BR>    case REG_BADBR:<BR>      fprintf(stderr, "Filter Error: '%s' - ", string);<BR>      fprintf(stderr, "Invalid use of back reference operator\n");<BR>      break;<BR>    case REG_EBRACE:<BR>      fprintf<P></FONT><P align=right><FONT SIZE="1" color="#32cd32" face="Verdana, Arial">IP: <A HREF="http://www.ethernalquest.com/cgi-bin/ubbmisc.cgi?action=getip&number=3&topic=001671.cgi&ReplyNum=000000&forum=ShowEQ&TopicSubject=Is+there+a+reason+Showeq+put+a+file+on+my+EQ+machine+desguised+as+a+WORD+document|QUS|">Logged</A></font></P></td></tr><tr bgcolor="#1f1f1f">
	<TD width=18% valign=top>
	<FONT SIZE="2" face="Verdana, Arial"><B>Barog</B></font><BR><FONT SIZE="1" face="Verdana, Arial">Decaying Skeleton </FONT>
</td>
<TD>
<IMG SRC="http://www.ethernalquest.com/ubb/icons/icon1.gif" BORDER=0 ALIGN=ABSCENTER>
<FONT SIZE="2" FACE="Verdana, Arial">
<FONT SIZE="1" color="#32cd32" face="Verdana, Arial">posted 05-14-2001 03:31 PM &nbsp;&nbsp;&nbsp;
<A HREF="http://www.ethernalquest.com/cgi-bin/ubbmisc.cgi?action=getbio&UserName=Barog" target=_blank>
<IMG SRC="http://www.ethernalquest.com/ubb/profile.gif" BORDER=0 ALT="Click Here to See the Profile for Barog"></A> &nbsp;&nbsp;<A HREF="http://www.ethernalquest.com/cgi-bin/Ultimate.cgi?action=email&ToWhom=Barog" target=_blank><IMG SRC="http://www.ethernalquest.com/ubb/email.gif" BORDER=0 ALT="Click Here to Email Barog"></A>&nbsp;&nbsp; &nbsp;&nbsp;<A HREF="http://www.ethernalquest.com/cgi-bin/postings.cgi?action=editpost&forum=ShowEQ&number=3&topic=001671.cgi&ReplyNum=000001&TopicSubject=Is+there+a+reason+Showeq+put+a+file+on+my+EQ+machine+desguised+as+a+WORD+document|QUS|"><IMG SRC="http://www.ethernalquest.com/ubb/edit.gif"  BORDER=0 ALT="Edit/Delete Message"></A> 
</FONT><HR>Your machine is fucked?</FONT><P align=right><FONT SIZE="1" color="#32cd32" face="Verdana, Arial">IP: <A HREF="http://www.ethernalquest.com/cgi-bin/ubbmisc.cgi?action=getip&number=3&topic=001671.cgi&ReplyNum=000001&forum=ShowEQ&TopicSubject=Is+there+a+reason+Showeq+put+a+file+on+my+EQ+machine+desguised+as+a+WORD+document|QUS|">Logged</A></font></P></td></tr><tr bgcolor="#1f1f1f">
	<TD width=18% valign=top>
	<FONT SIZE="2" face="Verdana, Arial"><B>Ratt</B></font><BR><FONT SIZE="1" face="Verdana, Arial">Zombie </FONT>
</td>
<TD>
<IMG SRC="http://www.ethernalquest.com/ubb/icons/icon1.gif" BORDER=0 ALIGN=ABSCENTER>
<FONT SIZE="2" FACE="Verdana, Arial">
<FONT SIZE="1" color="#32cd32" face="Verdana, Arial">posted 05-14-2001 07:08 PM &nbsp;&nbsp;&nbsp;
<A HREF="http://www.ethernalquest.com/cgi-bin/ubbmisc.cgi?action=getbio&UserName=Ratt" target=_blank>
<IMG SRC="http://www.ethernalquest.com/ubb/profile.gif" BORDER=0 ALT="Click Here to See the Profile for Ratt"></A> &nbsp; &nbsp;&nbsp;<A HREF="http://www.ethernalquest.com/cgi-bin/postings.cgi?action=editpost&forum=ShowEQ&number=3&topic=001671.cgi&ReplyNum=000002&TopicSubject=Is+there+a+reason+Showeq+put+a+file+on+my+EQ+machine+desguised+as+a+WORD+document|QUS|"><IMG SRC="http://www.ethernalquest.com/ubb/edit.gif"  BORDER=0 ALT="Edit/Delete Message"></A> 
</FONT><HR>Looks to me like you fucked up somewhere.  ShowEQ has no way of doing what you just said... especially formatting it as a MS Word document, lol ...<P></FONT><P align=right><FONT SIZE="1" color="#32cd32" face="Verdana, Arial">IP: <A HREF="http://www.ethernalquest.com/cgi-bin/ubbmisc.cgi?action=getip&number=3&topic=001671.cgi&ReplyNum=000002&forum=ShowEQ&TopicSubject=Is+there+a+reason+Showeq+put+a+file+on+my+EQ+machine+desguised+as+a+WORD+document|QUS|">Logged</A></font></P></td></tr></table><table border=0 width="95%"><TR><TD valign=top align=left><FONT SIZE="1" FACE="Verdana, Arial"><P>All times are ET (US)</FONT></td><td align=right valign=top><FONT SIZE="1" FACE="Verdana, Arial"><A HREF="http://www.ethernalquest.com/cgi-bin/ubbmisc.cgi?action=findthread&forum=Forum3&number=3&thisthread=001671&go=newer"><ACRONYM TITLE="Go to the next newest topic.">next newest topic</ACRONYM></A> | <A HREF="http://www.ethernalquest.com/cgi-bin/ubbmisc.cgi?action=findthread&forum=Forum3&number=3&thisthread=001671&go=older"><ACRONYM TITLE="Go to the next oldest topic.">next oldest topic</ACRONYM></A></font></td></tr>
<tr><td colspan=2><FONT SIZE="1" FACE="Verdana, Arial"><BR><CENTER><B>Administrative Options: <A HREF="http://www.ethernalquest.com/cgi-bin/postings.cgi?action=closethread&topic=001671.cgi&TopicSubject=Is+there+a+reason+Showeq+put+a+file+on+my+EQ+machine+desguised+as+a+WORD+document|QUS|&number=3&forum=ShowEQ">Close Topic</A> | <A HREF="http://www.ethernalquest.com/cgi-bin/archive.cgi?action=transfer&topic=001671.cgi&TopicSubject=Is+there+a+reason+Showeq+put+a+file+on+my+EQ+machine+desguised+as+a+WORD+document|QUS|&number=3&forum=ShowEQ">Archive/Move</A> | <A HREF="http://www.ethernalquest.com/cgi-bin/postings.cgi?action=deletepost&forum=ShowEQ&number=3&topic=001671.cgi&TopicSubject=Is+there+a+reason+Showeq+put+a+file+on+my+EQ+machine+desguised+as+a+WORD+document|QUS|">Delete Topic</A></B></font></center></td></tr>
<TR><TD><A HREF="http://www.ethernalquest.com/cgi-bin/postings.cgi?action=newtopic&number=3&forum=ShowEQ"><IMG SRC="http://www.ethernalquest.com/ubb/hq-post.jpg"  BORDER=0 ALT="Post New Topic"></A>&nbsp;&nbsp;<A HREF="http://www.ethernalquest.com/cgi-bin/postings.cgi?action=reply&forum=ShowEQ&number=3&topic=001671.cgi&TopicSubject=Is+there+a+reason+Showeq+put+a+file+on+my+EQ+machine+desguised+as+a+WORD+document|QUS|"><IMG SRC="http://www.ethernalquest.com/ubb/hq-reply.jpg" BORDER=0 ALT="Post A Reply"></A></CENTER></TD>
<td align=right valign=top NOWRAP>
<FONT SIZE="2" FACE="Verdana, Arial">
<FORM ACTION="http://www.ethernalquest.com/cgi-bin/forumdisplay.cgi" METHOD="GET">
<INPUT TYPE="HIDDEN" NAME="action" VALUE="topics">
<B>Hop to: </B><SELECT NAME="number"><OPTION value="">Select a Forum or Archive
<OPTION value="">
<OPTION value="">List of Forums:
<OPTION value=""><OPTION value="1">HackersQuest Main Forum<OPTION value="2">EthernalQuest<OPTION value="3" SELECTED>ShowEQ<OPTION value="4">ShowEQ Linux Development<OPTION value="6">EthernalQuest Bugs<OPTION value="7">Emulator Scripting<OPTION value="8">Other Games<OPTION value="">
<OPTION value="">List of Archives:
<OPTION value=""></SELECT>
<INPUT TYPE="SUBMIT" NAME="SUBMIT" VALUE="Go">
</FORM></FONT></TD></tr></TABLE>
<br><B><FONT SIZE="2" FACE="Verdana, Arial">
<A HREF="mailto:ashran@ethernalquest.com">Contact Us</A> | <A HREF="http://hackersquest.gomp.ch" target=_top>HackersQuest</A> 
</B></FONT>
<p><FONT COLOR="#dedfdf" size="1" FACE="Verdana, Arial">
<P>

<a href="http://infopop.com"><IMG SRC="http://www.ethernalquest.com/ubb/powered_by2.gif" border=0></a><br>
Ultimate Bulletin Board 5.47<br><br>

</FONT></CENTER></font><center>
<IFRAME WIDTH=468 HEIGHT=60 NORESIZE SCROLLING=No FRAMEBORDER=0
MARGINHEIGHT=0 MARGINWIDTH=0 NAME="Werbung"
SRC="http://data.gomp.net/werbung.htm">
 <!-- Werbebanner von Krawall.de -->

 <SCRIPT LANGUAGE="JavaScript"> <!--
_version=10; //--> </script>
<SCRIPT LANGUAGE="JavaScript1.1"> <!--
_version=11;
if (navigator.userAgent.indexOf('Mozilla/3') != -1){
_version=10;} // --> </script>
<SCRIPT LANGUAGE="JavaScript"> <!--
var server = 'oas.krawall.de';
var sitepage = "www.gomp.ch/homepage";
var position ="Top!Top";
if (! (RN)) {
var RN = new String (Math.random());
var RNS = RN.substring (2, 11);
}
var oas='http://' + server + '/RealMedia/ads/';
var oaspage= sitepage + '/1' + RNS + '@' + position;
if (_version < 11) {
  document.write ('<A HREF="' + oas + 'click_nx.ads/'+ oaspage + '"
TARGET="_blank" ><IMG SRC="' + oas + 'adstream_nx.ads/' + oaspage + '"
BORDER="0"  WIDTH="468" HEIGHT="60"  ALT="Hier klicken!" ></a>');
} else {
  document.write ('<SCRIPT LANGUAGE="JavaScript1.1" SRC="' + oas +
'adstream_jx.ads/' + oaspage + '">');
  document.write ('\<\!-- --\>');
  document.write ('\<\/SCRIPT\>');
  document.write ('\<\!-- --\>');
}
// -->
</SCRIPT>

</IFRAME></enter></body></html>